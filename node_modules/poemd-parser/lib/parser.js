"use strict";
exports.__esModule = true;
exports.parse = void 0;
var message_1 = require("./message");
var poem_1 = require("./poem");
var token_1 = require("./token");
var utils_1 = require("./utils");
function lex(code) {
    var tokens = [];
    var lastTokenIsVerse = function () { return tokens.length && typeof tokens[tokens.length - 1] == 'string'; };
    /** If true, a character other than whitespace occurred on this line. */
    var lineDirty = false;
    var lineExtended = false;
    var currentToken = '';
    /** Whitespace following a possible line extension character. */
    var lostCache = '';
    var verseIndentLevel = 0;
    var breakVerse = false;
    function pushToken() {
        lineDirty = false;
        // line isn't empty
        if (currentToken) {
            if (breakVerse) {
                tokens.push(token_1.TokenType.VerseBreak);
                breakVerse = false;
            }
            else if (verseIndentLevel)
                tokens.push(verseIndentLevel);
            tokens.push(currentToken);
            if (lineExtended)
                tokens.push(token_1.TokenType.VerseContinuation);
        }
        // line is empty and the last token is a verse
        else if (lastTokenIsVerse())
            tokens.push(token_1.TokenType.EndOfStanza);
    }
    function onChar(char) {
        switch (char) {
            case '\n':
                pushToken();
                lineExtended = false;
                lostCache = '';
                lineDirty = false;
                verseIndentLevel = 0;
                currentToken = '';
                break;
            case ' ':
            case '\t':
                if (lineDirty)
                    if (lineExtended)
                        lostCache += char;
                    else
                        currentToken += char;
                else
                    verseIndentLevel++;
                break;
            case '>':
                if (lineDirty || utils_1.getLast(tokens) == token_1.TokenType.VerseContinuation)
                    currentToken += char;
                else
                    breakVerse = true;
                lineDirty = true;
                break;
            case '\\':
                if (lineExtended) {
                    if (lostCache) {
                        currentToken += '\\' + lostCache;
                        lostCache = '';
                    }
                    else
                        currentToken += '\\';
                    lineExtended = false;
                }
                else {
                    lineDirty = true;
                    lineExtended = true;
                }
                break;
            default:
                lineDirty = true;
                currentToken += char;
        }
        if (lineExtended && !utils_1.oneOf(char, '\\', ' ', '\t', '\n')) {
            lineExtended = false;
            currentToken += '\\' + lostCache;
            lostCache = '';
        }
    }
    code.split('').forEach(onChar);
    pushToken();
    tokens.push(token_1.TokenType.EndOfFile);
    return tokens;
}
function parse(code) {
    var messages = [];
    var tokens = lex(code);
    var doc = new poem_1.Document();
    var poem = new poem_1.Poem();
    doc.addPoem(poem);
    var collectingHeader = false;
    var possibleHeaderVerses = [];
    var continueVerse = false;
    var breakVerse = false;
    var verseIndentLevel = 0;
    function checkForHeader() {
        // check if all marked verses except for the first one
        // start with a key name followed by `:'
        if (possibleHeaderVerses.every(function (v, i) { return i == 0 || v.content.search(/^\s*[\w\.]+\s*:/) != -1; })) {
            if (poem.title) {
                poem = new poem_1.Poem();
                doc.addPoem(poem);
            }
            poem.title = possibleHeaderVerses[0].content.substring(1);
            var attributes_1 = {};
            possibleHeaderVerses.forEach(function (v, i) {
                if (i == 0)
                    return;
                var matches = v.content.match(/^\s*([\w\.]+)\s*:(.*)/);
                attributes_1[matches[1]] = matches[2].trim();
            });
            for (var key in attributes_1) {
                var val = attributes_1[key];
                switch (key) {
                    case 'subtitle':
                        poem.subtitle = val;
                        break;
                    case 'author':
                        poem.author = val;
                        break;
                    case 'date':
                        poem.date = val;
                        break;
                    case 'lang':
                    case 'language':
                        poem.language = val;
                        break;
                    case 'paper':
                        doc.paper = val;
                        break;
                    case 'fontSize':
                        if (isNaN(+val))
                            messages.push(message_1.NUMERIC_VALUE_EXPECTED.specify({
                                key: 'fontSize',
                                val: val
                            }));
                        else
                            doc.fontSize = val;
                        break;
                    default:
                        messages.push(message_1.UNUSED_KEY.specify({ key: key }));
                }
            }
            poem.content.push(new poem_1.Stanza());
        }
        else {
            poem.content.push(new poem_1.Stanza());
            poem.content[0].content = possibleHeaderVerses;
        }
        collectingHeader = false;
        possibleHeaderVerses = [];
    }
    for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        if (typeof token == 'string') {
            if (token.search(/^# /) != -1)
                collectingHeader = true;
            if (collectingHeader)
                if (continueVerse) {
                    utils_1.getLast(possibleHeaderVerses).content += ' ' + token;
                    continueVerse = false;
                }
                else {
                    var verse = new poem_1.Verse(token, verseIndentLevel);
                    verseIndentLevel = 0;
                    if (breakVerse) {
                        verse.breakWith = utils_1.getLast(possibleHeaderVerses);
                        breakVerse = false;
                    }
                    possibleHeaderVerses.push(verse);
                }
            else {
                var lastStanza = utils_1.getLast(poem.content);
                if (!(lastStanza instanceof poem_1.Stanza)) {
                    lastStanza = new poem_1.Stanza();
                    poem.content.push(lastStanza);
                }
                if (continueVerse && lastStanza.content.length)
                    utils_1.getLast(lastStanza.content).content += token;
                else {
                    var verse = new poem_1.Verse(token, verseIndentLevel);
                    verseIndentLevel = 0;
                    if (breakVerse) {
                        if (!lastStanza.content.length && utils_1.getLast(poem.content, 1)) {
                            var lastStanza_1 = utils_1.getLast(poem.content, 1);
                            if (lastStanza_1 instanceof poem_1.SectionTitle)
                                verse.breakWith = lastStanza_1;
                            else
                                verse.breakWith = utils_1.getLast(lastStanza_1.content);
                        }
                        else {
                            var breakWith = utils_1.getLast(lastStanza.content);
                            if (breakWith instanceof poem_1.Verse)
                                verse.breakWith = breakWith;
                        }
                        breakVerse = false;
                    }
                    lastStanza.content.push(verse);
                }
                continueVerse = false;
                breakVerse = false;
            }
        }
        else
            switch (token) {
                case token_1.TokenType.VerseContinuation:
                    continueVerse = true;
                    break;
                case token_1.TokenType.VerseBreak:
                    breakVerse = true;
                    break;
                case token_1.TokenType.EndOfFile:
                case token_1.TokenType.EndOfStanza:
                    continueVerse = false;
                    if (collectingHeader)
                        checkForHeader();
                    else {
                        var t = void 0;
                        var ls = utils_1.getLast(poem.content);
                        if (ls instanceof poem_1.Stanza && ls.content.length == 1) {
                            var lv = utils_1.getLast(ls.content);
                            var c = lv.content.replace(/^## /, '');
                            if (lv.content != c) {
                                t = new poem_1.SectionTitle(c);
                                poem.content.pop();
                            }
                        }
                        poem.content.push(t !== null && t !== void 0 ? t : new poem_1.Stanza());
                    }
                    collectingHeader = false;
                    break;
                default:
                    verseIndentLevel = token;
            }
    }
    doc.clean();
    return { tokens: tokens, document: doc, messages: messages };
}
exports.parse = parse;
//# sourceMappingURL=parser.js.map